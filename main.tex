%para compilar pdflatex main.text

\documentclass[a4paper,11pt,landscape,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage[spanish]{babel}

% Aumenta la separación entre columnas
\setlength{\columnsep}{25pt}

\geometry{left=20mm,right=20mm,top=20mm,bottom=20mm}

% Configuración del código en C++
\lstset{
  language=C++,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=8pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  breaklines=true,
  breakatwhitespace=true,
  columns=flexible
}

\title{Ayudamemoria}
\author{My Room Is Random Sorted}

\begin{document}

\begin{center}
    \LARGE\textbf{Ayudamemoria}\\[1em]
    \large My room is random Sorted\\[1em]
    \normalsize \today\\[1em]
\end{center}

\tableofcontents

\section{Template}

\lstinputlisting{src/template.cpp}

\subsection{run.sh}

\lstinputlisting{src/run.sh}

\subsection{comp.sh}

\lstinputlisting{src/comp.sh}

\subsection{Makefile}

\lstinputlisting{src/Makefile}

\section{Estructuras de datos}

\subsection{Sparse Table}

\lstinputlisting{src/estructuras/sparse_table.cpp}

\subsection{Segment Tree}

\lstinputlisting{src/estructuras/segment_tree.cpp}

\subsection{Segment Tree Lazy}

\lstinputlisting{src/estructuras/segment_tree_lazy.cpp}

\subsection{Fenwick Tree}

\lstinputlisting{src/estructuras/fenwick.cpp}

\subsection{Tabla Aditiva}

\lstinputlisting{src/estructuras/tablitaAditiva.cpp}

\subsection{Union Find}

\lstinputlisting{src/estructuras/union_find.cpp}

\section{Matemática}

\subsection{Criba Lineal}

\lstinputlisting{src/matematica/criba.cpp}

\subsection{Phollard's Rho}

\lstinputlisting{src/matematica/phollards_rho.cpp}

\subsection{Divisores}

\lstinputlisting{src/matematica/divisores.cpp}

\subsection{Inversos Modulares}

\lstinputlisting{src/matematica/euclides_extendido.cpp}

\lstinputlisting{src/matematica/inversos_modulares.cpp}

\subsection{Catalan}

\lstinputlisting{src/matematica/catalan.cpp}

\subsection{Lucas}

\lstinputlisting{src/matematica/lucas.cpp}

\subsection{Stirling-Bell}

\lstinputlisting{src/matematica/stirling_bell.cpp}

\subsection{DP Factoriales}

\lstinputlisting{src/matematica/fact.cpp}

\subsection{Estructura de Fracción}

\lstinputlisting{src/matematica/frac.cpp}

\section{Geometria}

\subsection{Formulas}

\begin{itemize}
  \item \textbf{Ley de cosenos}: sea un triangulo con lados A, B, C y angulos $\alpha$, $\beta$, $\gamma$ entre A, B y C, respectivamente.
  $$A^2=B^2+C^2-2*cos(\alpha)$$
  $$B^2=A^2+C^2-2*cos(\beta)$$
  $$C^2=A^2+B^2-2*cos(\gamma)$$
  \item \textbf{Ley de senos}: idem
  $$\frac{sin(\alpha)}{A}=\frac{sin(\beta)}{B}=\frac{sin(\gamma)}{C}$$
  \item \textbf{Valor de PI}: $\pi=acos(-1.0)$ o $\pi=4*atan(1.0)$
  \item \textbf{Longitud de una cuerda}: sea $\alpha$ el angulo descripto por una cuerda de longitud $l$.
  $$l=\sqrt{2*r^2*(1-cos(\alpha))}$$
  \item \textbf{Formula de Heron}: sea un triangulo con lados a, b, c y semiperimetro s. El area del triangulo es
  $$A=\sqrt{s*(s-a)*(s-b)*(s-c)}$$
  \item \textbf{Teorema de Pick}: sean A, I y B el area de un poligono, la cantidad de puntos con coordenadas enteras dentro del mismo y la cantidad de puntos con coordenadas enteras en el borde del mismo.
  $$A=I+\frac{B}{2}-1$$
\end{itemize}

\subsection{Punto}

\lstinputlisting{src/geometria/point.cpp}

\subsection{Linea}

\lstinputlisting{src/geometria/line.cpp}

\subsection{Poligono}

\lstinputlisting{src/geometria/polygon.cpp}

\subsection{Circulo}

\lstinputlisting{src/geometria/circle.cpp}

\subsection{Convex Hull}

\lstinputlisting{src/geometria/convex_hull.cpp}

\subsection{Orden Radial}

\lstinputlisting{src/geometria/radial_sort.cpp}

\subsection{Par de puntos más cercano}

\lstinputlisting{src/geometria/closest_pair.cpp}

\subsection{Arbol KD}

\lstinputlisting{src/geometria/kdtree.cpp}

\subsection{Suma de Minkowski}

\lstinputlisting{src/geometria/minkowski_sum.cpp}

\subsection{Sweep Space}

\lstinputlisting{src/geometria/sweep_space.cpp}

\subsection{Concepts}

\lstinputlisting{src/geometria/concepts.cpp}

\section{Strings}

\subsection{Hashing}

\lstinputlisting{src/strings/hashing.cpp}

\subsection{Suffix Array}

\lstinputlisting{src/strings/suffix_array.cpp}

\subsection{String Functions}

\lstinputlisting{src/strings/string_functions.cpp}

\subsection{Kmp}

\lstinputlisting{src/strings/kmp.cpp}

\subsection{Manacher}

\lstinputlisting{src/strings/manacher.cpp}

\subsection{Mínima Rotación Lexicográfica}

\lstinputlisting{src/strings/lyndon.cpp}

\subsection{Trie}

\lstinputlisting{src/strings/trie.cpp}

\section{Grafos}

\subsection{Dikjstra}

\lstinputlisting{src/grafos/dikjstra.cpp}

\subsection{LCA}

\lstinputlisting{src/grafos/lowest_common_ancestor.cpp}

\subsection{Binary Lifting}

\lstinputlisting{src/grafos/binary_lifting.cpp}

\subsection{Toposort}

\lstinputlisting{src/grafos/toposort.cpp}

\subsection{Deteccion ciclos negativos}

\lstinputlisting{src/grafos/floyd_warshall.cpp}

\subsection{Camino Euleriano}

\lstinputlisting{src/grafos/eulerian_path.cpp}

\subsection{Camino Hamiltoniano}

\lstinputlisting{src/grafos/hamiltonian_path.cpp}

\subsection{Tarjan SCC}

\lstinputlisting{src/grafos/tarjan_scc.cpp}

\subsection{Bellman-Ford}

\lstinputlisting{src/grafos/bellman_ford.cpp}

\subsection{Puentes y Articulacion}

\lstinputlisting{src/grafos/bridge_articulation_point.cpp}

\subsection{Kruskal}

\lstinputlisting{src/grafos/kruskal.cpp}

\subsection{Chequeo Bipartito}

\lstinputlisting{src/grafos/bipartite.cpp}

\subsection{HLD}

\lstinputlisting{src/grafos/hld.cpp}

\subsection{Max Tree Matching}

\lstinputlisting{src/grafos/max_tree_matching.cpp}

\subsection{Min Tree Vertex Cover}

\lstinputlisting{src/grafos/min_tree_vertex_cover.cpp}

\section{Flujo}

\subsection{Dinic}

\lstinputlisting{src/flujo/dinic.cpp}

\subsection{Min Cost Max Flow}

\lstinputlisting{src/flujo/min_cost_max_flow.cpp}

\subsection{Hopcroft Karp}

\lstinputlisting{src/flujo/hopcroft_karp.cpp}

\subsection{Kuhn}

\lstinputlisting{src/flujo/kuhn.cpp}

\subsection{Min Vertex Cover Bipartito}

\lstinputlisting{src/flujo/min_bipartite_vertex_cover.cpp}

\subsection{Hungarian}

\lstinputlisting{src/flujo/hungarian.cpp}

\section{Optimización}

\subsection{Ternary Search}

\lstinputlisting{src/optimizacion/ternary_search.cpp}

\subsection{Longest Increasing Subsequence}

\lstinputlisting{src/optimizacion/lis.cpp}

\section{Otros}

\subsection{Mo}

\lstinputlisting{src/otros/mo.cpp}

\subsection{Fijar el numero de decimales}

\lstinputlisting{src/otros/decimales.cpp}

\subsection{Hash Table (Unordered Map/ Unordered Set)}

\lstinputlisting{src/otros/hash_table.cpp}

\subsection{Indexed Set}

\lstinputlisting{src/otros/indexed_set.cpp}

\subsection{Iterar subconjuntos}

\begin{itemize}
  \item Iterar por todos los subconjuntos de n elementos $O(2^n)$.
  \begin{lstlisting}
    for(int bm=0; bm<(1<<n); bm++)
  \end{lstlisting}

  \item Iterar por cada superconjunto de un subconjunto de n elementos $O(2^n)$.
  \begin{lstlisting}
    for(int sbm=~bm; sbm; sbm=(sbm-1)&(~bm)) // super=bm&sbm
  \end{lstlisting}

  \item Iterar por cada subconjunto de un subconjunto de n elementos $O(2^n)$.
  \begin{lstlisting}
    for(int sbm=bm; sbm; sbm=(sbm-1)&bm) // sub=sbm
  \end{lstlisting}

  \item Para cada subconjunto de n elementos, iterar por cada superconjunto $O(3^n)$.
  \begin{lstlisting}
    for(int bm=0; bm<(1<<n); bm++)
      for(int sbm=~bm; sbm; sbm=(sbm-1)&(~bm)) // super=bm&sbm
  \end{lstlisting}

  \item Para cada subconjunto de n elementos, iterar por cada subsubconjunto $O(3^n)$.
  \begin{lstlisting}
    for(int bm=0; bm<(1<<n); bm++)
      for(int sbm=bm; sbm; sbm=(sbm-1)&(bm)) // sub=sbm
  \end{lstlisting}
\end{itemize}

\subsection{Simpson}

\lstinputlisting{src/otros/simpson.cpp}

\end{document}
